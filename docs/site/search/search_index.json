{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"docs/","text":"Template Components # Template Components is a library that allows you to write server-side components as single Jinja template files, and use them as HTML tags without doing any importing. A component is a fragment of your UI . It can embrace an entire page, a single comment or just an avatar image: components/Greeting.html.jinja {# message = ... #} < div class = \"greeting\" > {{ message }} </ div > And you use it like this: components/Page.html.jinja < div > < Greeting message = \"Hello world!\" /> </ div > Components are reusable, testable and encapsulated. You can think of them as an evolution of Jinja\u2019s macros, inspired by React and Vue. Why use Template Components? # We work hard on writing code that is encapsulated, do one thing well, and that makes clear what arguments it takes and what kind of output it return. Template code, however, often fails even basic code standards : long methods, deep conditional nesting, and mystery variables everywhere. Client-side components (like the ones you write with React) solves all of these problems and introduces a whole bag of complexity. More importantly, you can\u2019t use them if your app is not a \u201csingle-page application\u201d. Or rather, you couldn\u2019t, until now. With this library, you can use the power of components in a server-side-rendered application. Resources # Source code (MIT Licensed) PyPI Change log","title":"Intro"},{"location":"docs/#templatecomponents","text":"Template Components is a library that allows you to write server-side components as single Jinja template files, and use them as HTML tags without doing any importing. A component is a fragment of your UI . It can embrace an entire page, a single comment or just an avatar image: components/Greeting.html.jinja {# message = ... #} < div class = \"greeting\" > {{ message }} </ div > And you use it like this: components/Page.html.jinja < div > < Greeting message = \"Hello world!\" /> </ div > Components are reusable, testable and encapsulated. You can think of them as an evolution of Jinja\u2019s macros, inspired by React and Vue.","title":"Template Components"},{"location":"docs/#why-use-templatecomponents","text":"We work hard on writing code that is encapsulated, do one thing well, and that makes clear what arguments it takes and what kind of output it return. Template code, however, often fails even basic code standards : long methods, deep conditional nesting, and mystery variables everywhere. Client-side components (like the ones you write with React) solves all of these problems and introduces a whole bag of complexity. More importantly, you can\u2019t use them if your app is not a \u201csingle-page application\u201d. Or rather, you couldn\u2019t, until now. With this library, you can use the power of components in a server-side-rendered application.","title":"Why use Template Components?"},{"location":"docs/#resources","text":"Source code (MIT Licensed) PyPI Change log","title":"Resources"},{"location":"docs/guide/","text":"Getting started # Conventions # A component is a .jinja file inside a folder, commonly yourapp/components . You can also use subfolders inside to organize your components. The component name is the name of the file without extensions, and must begin with an uppercase letter. All components are auto-imported so the name of a component must be unique. Installation # Install the package using pip . pip install tcom Usage # The first thing you must do in your app is to create a \u201ccatalog\u201d of components. This is the object that manage the components and global settings. Then, you add to the catalog the folder(s) with your components. from tcom import Catalog catalog = Catalog () catalog . add_folder ( \"myapp/components\" ) You use the catalog to render a parent component from your views: def myview (): ... return catalog . render ( \"ComponentName\" , title = \"Lorem ipsum\" , message = \"Hello\" , ) The components are .jinja files whose first letter must be in uppercase. They can begin with a Jinja comment where it declare what attributes it takes. This metadata is in TOML format. {# title = ... message = ... #} < h1 > {{ title }} </ h1 > < div > {{ message }} . This is my component </ div > Jinja # Template Components use Jinja internally to render the templates. You can add your own global variables and functions, filters, tests, and Jinja extensions when creating the catalog: from tcom import Catalog catalog = Catalog ( globals = { ... }, filters = { ... }, tests = { ... }, extensions = [], ) or afterwards, directly on the created Jinja Environment at catalog.jinja_env . If you use Flask , for example, you should pass the values of its own Jinja environment: app = Flask ( __name__ ) catalog = tcom . Catalog ( globals = app . jinja_env . globals , filters = app . jinja_env . filters , tests = app . jinja_env . tests , extensions = app . jinja_env . extensions , ) The \u201cdo\u201d extension is enabled by default, so you can write things like: {% do attrs.add_class ( \"btn\" ) %}","title":"Getting started"},{"location":"docs/guide/#getting-started","text":"","title":"Getting started"},{"location":"docs/guide/#conventions","text":"A component is a .jinja file inside a folder, commonly yourapp/components . You can also use subfolders inside to organize your components. The component name is the name of the file without extensions, and must begin with an uppercase letter. All components are auto-imported so the name of a component must be unique.","title":"Conventions"},{"location":"docs/guide/#installation","text":"Install the package using pip . pip install tcom","title":"Installation"},{"location":"docs/guide/#usage","text":"The first thing you must do in your app is to create a \u201ccatalog\u201d of components. This is the object that manage the components and global settings. Then, you add to the catalog the folder(s) with your components. from tcom import Catalog catalog = Catalog () catalog . add_folder ( \"myapp/components\" ) You use the catalog to render a parent component from your views: def myview (): ... return catalog . render ( \"ComponentName\" , title = \"Lorem ipsum\" , message = \"Hello\" , ) The components are .jinja files whose first letter must be in uppercase. They can begin with a Jinja comment where it declare what attributes it takes. This metadata is in TOML format. {# title = ... message = ... #} < h1 > {{ title }} </ h1 > < div > {{ message }} . This is my component </ div >","title":"Usage"},{"location":"docs/guide/#jinja","text":"Template Components use Jinja internally to render the templates. You can add your own global variables and functions, filters, tests, and Jinja extensions when creating the catalog: from tcom import Catalog catalog = Catalog ( globals = { ... }, filters = { ... }, tests = { ... }, extensions = [], ) or afterwards, directly on the created Jinja Environment at catalog.jinja_env . If you use Flask , for example, you should pass the values of its own Jinja environment: app = Flask ( __name__ ) catalog = tcom . Catalog ( globals = app . jinja_env . globals , filters = app . jinja_env . filters , tests = app . jinja_env . tests , extensions = app . jinja_env . extensions , ) The \u201cdo\u201d extension is enabled by default, so you can write things like: {% do attrs.add_class ( \"btn\" ) %}","title":"Jinja"},{"location":"docs/guide/anatomy/","text":"Anatomy of a component #","title":"Anatomy of a component"},{"location":"docs/guide/anatomy/#anatomy-of-a-component","text":"","title":"Anatomy of a component"},{"location":"docs/guide/attributes/","text":"Component Attributes # More often than not, a component takes one or more attributes to render. Every attribute must be declared in the metadata section (the comment at the top) of the component. components/Form.html.jinja {# action = ... method = 'post' multipart = false #} < form method = \" {{ method }} \" action = \" {{ action }} \" {% - if multipart %} enctype = \"multipart/form-data\" {% endif %} > {{ content }} </ form > In this example, the component takes three attributes: \u201caction\u201d, \u201cmethod\u201d, and \u201cmultipart\u201d. The last two have a default value, so they are optional, but the first one has ... as value*. That means that it must be passed when rendering this component. So all of these are valid forms to use this component: < Form action = \"/new\" > ... </ Form > < Form action = \"/new\" method = \"PATCH\" > ... </ Form > < Form multipart = {{ false }} action=\"/new\" > ... </ Form > The values of the declared attributes can be used in the template as values with the same name. Non-string attributes # In the example above, both \u201caction\u201d and \u201cmethod\u201d are strings, but \u201cmultipart\u201d is a boolean, so we cannot pass it like multipart=\"false\" because that will make it a string that evaluates as True , which is the opposite of what we want. Instead, we must use Jinja\u2019s print variable syntax ( {{ value }} ). Inside, you can use datetimes, objects, Python expressions, etc. {# A datetime value #} < DateTime date = {{ datetime_value }} / > {# A query result #} < Post post = {{ post }} / > {# In-place calculations #} < FooBar number = {{ 2 ** 10 }} / > {# A list #} < FooBar items = {{ [ 1 , 2 , 3 , 4 ] }} / > Components with content # So far we have seen self-closing components, but there is another, much more useful type: components that wrap other HTML content and/or other components. {# Self-closing component #} < Name attributes /> {# Component with content #} < Name attributes > ...content here... </ Name > A great use case is to make layout components: components/PageLayout.html.jinja {# title = ... #} <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > {{ title }} </ title > </ head > < body > {{ content }} </ body > components/ArchivePage.html.jinja {# posts = ... #} < PageLayout title = \"Archive\" > {% for post in posts %} < Post post = {{ post }} / > {% endfor %} </ PageLayout > Everything between the open and close tags of the components will be rendered and passed to the PageLayout component as a special content variable. To test a component in isolation, you can also manually send a content attribute: catalog . render ( \"PageLayout\" , title = \"Hello world\" , content = \"TEST\" ) Extra attributes # If you pass attributes not declared in a component, those are not discarded, but rather collected in a attrs object. Read more about it in the next section.","title":"Component Attributes"},{"location":"docs/guide/attributes/#component-attributes","text":"More often than not, a component takes one or more attributes to render. Every attribute must be declared in the metadata section (the comment at the top) of the component. components/Form.html.jinja {# action = ... method = 'post' multipart = false #} < form method = \" {{ method }} \" action = \" {{ action }} \" {% - if multipart %} enctype = \"multipart/form-data\" {% endif %} > {{ content }} </ form > In this example, the component takes three attributes: \u201caction\u201d, \u201cmethod\u201d, and \u201cmultipart\u201d. The last two have a default value, so they are optional, but the first one has ... as value*. That means that it must be passed when rendering this component. So all of these are valid forms to use this component: < Form action = \"/new\" > ... </ Form > < Form action = \"/new\" method = \"PATCH\" > ... </ Form > < Form multipart = {{ false }} action=\"/new\" > ... </ Form > The values of the declared attributes can be used in the template as values with the same name.","title":"Component Attributes"},{"location":"docs/guide/attributes/#non-string-attributes","text":"In the example above, both \u201caction\u201d and \u201cmethod\u201d are strings, but \u201cmultipart\u201d is a boolean, so we cannot pass it like multipart=\"false\" because that will make it a string that evaluates as True , which is the opposite of what we want. Instead, we must use Jinja\u2019s print variable syntax ( {{ value }} ). Inside, you can use datetimes, objects, Python expressions, etc. {# A datetime value #} < DateTime date = {{ datetime_value }} / > {# A query result #} < Post post = {{ post }} / > {# In-place calculations #} < FooBar number = {{ 2 ** 10 }} / > {# A list #} < FooBar items = {{ [ 1 , 2 , 3 , 4 ] }} / >","title":"Non-string attributes"},{"location":"docs/guide/attributes/#components-with-content","text":"So far we have seen self-closing components, but there is another, much more useful type: components that wrap other HTML content and/or other components. {# Self-closing component #} < Name attributes /> {# Component with content #} < Name attributes > ...content here... </ Name > A great use case is to make layout components: components/PageLayout.html.jinja {# title = ... #} <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > {{ title }} </ title > </ head > < body > {{ content }} </ body > components/ArchivePage.html.jinja {# posts = ... #} < PageLayout title = \"Archive\" > {% for post in posts %} < Post post = {{ post }} / > {% endfor %} </ PageLayout > Everything between the open and close tags of the components will be rendered and passed to the PageLayout component as a special content variable. To test a component in isolation, you can also manually send a content attribute: catalog . render ( \"PageLayout\" , title = \"Hello world\" , content = \"TEST\" )","title":"Components with content"},{"location":"docs/guide/attributes/#extra-attributes","text":"If you pass attributes not declared in a component, those are not discarded, but rather collected in a attrs object. Read more about it in the next section.","title":"Extra attributes"},{"location":"docs/guide/css_and_js/","text":"Managing the CSS and JS #","title":"Managing the CSS and JS"},{"location":"docs/guide/css_and_js/#managing-the-css-and-js","text":"","title":"Managing the CSS and JS"},{"location":"docs/guide/extra/","text":"Extra Attributes # If you pass attributes not declared in a component, those are not discarded, but rather collected in a attrs object that can render these extra attributes calling attrs.render() For example, this component: components/Card.html.jinja {# title = ... #} < div {{ attrs.render () }} > < h1 > {{ title }} </ h1 > {{ content }} </ div > Called as: < Card title = \"Products\" class = \"bg-blue-500 mb-10\" open > bla </ Card > Will be rendered as: < div class = \"bg-blue-500 mb-10\" open > < h1 > Products </ h1 > bla </ div > You can add or remove attributes before rendering them using the other methods of the attrs object. For example: {# title = ... #} {% do attrs.add_class ( \"card\" ) - %} < div {{ attrs.render () }} > < h1 > {{ title }} </ h1 > {{ content }} </ div > attrs methods # .add(name, value=True) # Adds an attribute or sets a property. Pass a name and a value to set an attribute. Omit the value or use True as value to set a property instead. {% do attrs.add ( \"disabled\" ) %} {% do attrs.add ( \"readonly\" , True ) %} {% do attrs.add ( \"data-test\" , \"foobar\" ) %} {% do attrs.add ( \"id\" , 3 ) %} .remove(name) # Removes an attribute or property. {% if active - %} {% do attrs.remove ( \"disabled\" ) %} {% - endif %} .add_class(name) # .add_classes(name1, name2, ...) # Adds one or more classes to the list of classes (both are actually the same method). {% do attrs.add_class ( \"card\" ) %} {% do attrs.add_classes ( \"active\" , \"animated\" , \"bright\" ) %} {% do attrs.add_classes ( \"active animated bright\" ) %} .remove_class(name) # .remove_classes(name1, name2, ...) # Removes one or more classes from the list of classes (both are actually the same method). {% do attrs.remove_class ( \"hidden\" ) %} {% do attrs.remove_classes ( \"active\" , \"animated\" ) %} .setdefault(name, value=True) # Adds an attribute or sets a property, but only if it\u2019s not already present . Pass a name and a value to set an attribute. Omit the value or use True as value to set a property instead. {% do attrs.setdefault ( \"aria-label\" , \"Products\" ) %} .update(dd=None, **kw) # Updates several attributes/properties with the values of dd and kw dicts. {% - do attrs.update ( role = \"tab\" , aria_selected = \"true\" if active else \"false\" , aria_controls = target , tabindex = \"0\" if active else \"-1\" , ) - %} The underscores in the names will be translated automatically to dashes, so aria_selected will become the attribute aria-selected . .get(name, default=None) # Returns the value of the attribute or property, or the default value if it doesn\u2019t exists. {% - set role = attrs.get ( \"role\" , \"tab\" ) .render() # Renders the attributes and properties as a string. To provide consistent output, the attributes and properties are sorted by name and rendered like this: <sorted attributes> + <sorted properties> . < button {{ attrs.render () }} > {{ content }} </ button > Warning Using {{ attrs.render() }} as attributes for other component will not work , because the components are translated to macros before the page render. You must pass them as the special attribute __attrs . {#--- WRONG \ud83d\ude35 ---#} < MyButton {{ attrs.render () }} /> {#--- GOOD \ud83d\udc4d ---#} < MyButton __attrs = {{ attrs }} / > {#--- ALSO AN OPTION ---#} {# btn_class = '' #} < MyButton class = {{ btn_class }} / >","title":"Extra Attributes"},{"location":"docs/guide/extra/#extra-attributes","text":"If you pass attributes not declared in a component, those are not discarded, but rather collected in a attrs object that can render these extra attributes calling attrs.render() For example, this component: components/Card.html.jinja {# title = ... #} < div {{ attrs.render () }} > < h1 > {{ title }} </ h1 > {{ content }} </ div > Called as: < Card title = \"Products\" class = \"bg-blue-500 mb-10\" open > bla </ Card > Will be rendered as: < div class = \"bg-blue-500 mb-10\" open > < h1 > Products </ h1 > bla </ div > You can add or remove attributes before rendering them using the other methods of the attrs object. For example: {# title = ... #} {% do attrs.add_class ( \"card\" ) - %} < div {{ attrs.render () }} > < h1 > {{ title }} </ h1 > {{ content }} </ div >","title":"Extra Attributes"},{"location":"docs/guide/extra/#attrs-methods","text":"","title":"attrs methods"},{"location":"docs/guide/extra/#addname-valuetrue","text":"Adds an attribute or sets a property. Pass a name and a value to set an attribute. Omit the value or use True as value to set a property instead. {% do attrs.add ( \"disabled\" ) %} {% do attrs.add ( \"readonly\" , True ) %} {% do attrs.add ( \"data-test\" , \"foobar\" ) %} {% do attrs.add ( \"id\" , 3 ) %}","title":".add(name, value=True)"},{"location":"docs/guide/extra/#removename","text":"Removes an attribute or property. {% if active - %} {% do attrs.remove ( \"disabled\" ) %} {% - endif %}","title":".remove(name)"},{"location":"docs/guide/extra/#add_classname","text":"","title":".add_class(name)"},{"location":"docs/guide/extra/#add_classesname1-name2","text":"Adds one or more classes to the list of classes (both are actually the same method). {% do attrs.add_class ( \"card\" ) %} {% do attrs.add_classes ( \"active\" , \"animated\" , \"bright\" ) %} {% do attrs.add_classes ( \"active animated bright\" ) %}","title":".add_classes(name1, name2, ...)"},{"location":"docs/guide/extra/#remove_classname","text":"","title":".remove_class(name)"},{"location":"docs/guide/extra/#remove_classesname1-name2","text":"Removes one or more classes from the list of classes (both are actually the same method). {% do attrs.remove_class ( \"hidden\" ) %} {% do attrs.remove_classes ( \"active\" , \"animated\" ) %}","title":".remove_classes(name1, name2, ...)"},{"location":"docs/guide/extra/#setdefaultname-valuetrue","text":"Adds an attribute or sets a property, but only if it\u2019s not already present . Pass a name and a value to set an attribute. Omit the value or use True as value to set a property instead. {% do attrs.setdefault ( \"aria-label\" , \"Products\" ) %}","title":".setdefault(name, value=True)"},{"location":"docs/guide/extra/#updateddnone-kw","text":"Updates several attributes/properties with the values of dd and kw dicts. {% - do attrs.update ( role = \"tab\" , aria_selected = \"true\" if active else \"false\" , aria_controls = target , tabindex = \"0\" if active else \"-1\" , ) - %} The underscores in the names will be translated automatically to dashes, so aria_selected will become the attribute aria-selected .","title":".update(dd=None, **kw)"},{"location":"docs/guide/extra/#getname-defaultnone","text":"Returns the value of the attribute or property, or the default value if it doesn\u2019t exists. {% - set role = attrs.get ( \"role\" , \"tab\" )","title":".get(name, default=None)"},{"location":"docs/guide/extra/#render","text":"Renders the attributes and properties as a string. To provide consistent output, the attributes and properties are sorted by name and rendered like this: <sorted attributes> + <sorted properties> . < button {{ attrs.render () }} > {{ content }} </ button > Warning Using {{ attrs.render() }} as attributes for other component will not work , because the components are translated to macros before the page render. You must pass them as the special attribute __attrs . {#--- WRONG \ud83d\ude35 ---#} < MyButton {{ attrs.render () }} /> {#--- GOOD \ud83d\udc4d ---#} < MyButton __attrs = {{ attrs }} / > {#--- ALSO AN OPTION ---#} {# btn_class = '' #} < MyButton class = {{ btn_class }} / >","title":".render()"},{"location":"docs/guide/third_party/","text":"Using components written by others #","title":"Using components written by others"},{"location":"docs/guide/third_party/#using-components-written-by-others","text":"","title":"Using components written by others"}]}
