{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The power of components in your server-side-rendered Python web app. Convinced already? See the Documentation Reusable, encapsulated, and testable. Write server-side components as single Jinja template files. Use them as HTML tags without doing any importing. Say goodbye to spaghetti templates. We want our python code to be easy to understand and test. Template code, however, often fails even basic code standards : long methods, deep conditional nesting, and mystery variables everywhere. But when it's all as components, you'll see where everything is, understand what are the possible states of every piece of UI, and know exactly what data need to have. You can replace all your templates with components . Using {{\"{% extend %}\"}} for a base layout? Create a Page component instead! Quick to write, amazing to use. This is how a component looks like: Ready to get going? Engage: See the Documentation Millions of people clicked a button in the last week alone!","title":"Home"},{"location":"guide/","text":"Getting started # Installation # Install the package using pip . pip install tcom Usage # The first thing you must do in your app is to create a \u201ccatalog\u201d of components. This is the object that manage the components and global settings. Then, you add to the catalog the folder(s) with your components. from tcom import Catalog catalog = Catalog () catalog . add_folder ( \"myapp/components\" ) You use the catalog to render a parent component from your views: def myview (): ... return catalog . render ( \"ComponentName\" , title = \"Lorem ipsum\" , message = \"Hello\" , ) Components # The components are .jinja . The name of the file before the first dot is the component name and it must begin with an uppercase letter. All components are auto-imported across all sources so the name of a component must be unique. A component can begin with a Jinja comment where it declare what attributes it takes. This metadata is in TOML format. {# title = ... message = ... #} < h1 > {{ title }} </ h1 > < div > {{ message }} . This is my component </ div > Jinja # Template Components use Jinja internally to render the templates. You can add your own global variables and functions, filters, tests, and Jinja extensions when creating the catalog: from tcom import Catalog catalog = Catalog ( globals = { ... }, filters = { ... }, tests = { ... }, extensions = [], ) or afterwards, directly on the created Jinja Environment at catalog.jinja_env . If you use Flask , for example, you should pass the values of its own Jinja environment: app = Flask ( __name__ ) catalog = tcom . Catalog ( globals = app . jinja_env . globals , filters = app . jinja_env . filters , tests = app . jinja_env . tests , extensions = app . jinja_env . extensions , ) The \u201cdo\u201d extension is enabled by default, so you can write things like: {% do attrs.add_class ( \"btn\" ) %}","title":"Getting started"},{"location":"guide/#getting-started","text":"","title":"Getting started"},{"location":"guide/#installation","text":"Install the package using pip . pip install tcom","title":"Installation"},{"location":"guide/#usage","text":"The first thing you must do in your app is to create a \u201ccatalog\u201d of components. This is the object that manage the components and global settings. Then, you add to the catalog the folder(s) with your components. from tcom import Catalog catalog = Catalog () catalog . add_folder ( \"myapp/components\" ) You use the catalog to render a parent component from your views: def myview (): ... return catalog . render ( \"ComponentName\" , title = \"Lorem ipsum\" , message = \"Hello\" , )","title":"Usage"},{"location":"guide/#components","text":"The components are .jinja . The name of the file before the first dot is the component name and it must begin with an uppercase letter. All components are auto-imported across all sources so the name of a component must be unique. A component can begin with a Jinja comment where it declare what attributes it takes. This metadata is in TOML format. {# title = ... message = ... #} < h1 > {{ title }} </ h1 > < div > {{ message }} . This is my component </ div >","title":"Components"},{"location":"guide/#jinja","text":"Template Components use Jinja internally to render the templates. You can add your own global variables and functions, filters, tests, and Jinja extensions when creating the catalog: from tcom import Catalog catalog = Catalog ( globals = { ... }, filters = { ... }, tests = { ... }, extensions = [], ) or afterwards, directly on the created Jinja Environment at catalog.jinja_env . If you use Flask , for example, you should pass the values of its own Jinja environment: app = Flask ( __name__ ) catalog = tcom . Catalog ( globals = app . jinja_env . globals , filters = app . jinja_env . filters , tests = app . jinja_env . tests , extensions = app . jinja_env . extensions , ) The \u201cdo\u201d extension is enabled by default, so you can write things like: {% do attrs.add_class ( \"btn\" ) %}","title":"Jinja"},{"location":"guide/attributes/","text":"Component Attributes # More often than not, a component takes one or more attributes to render. Every attribute must be declared in the metadata section (the comment at the top) of the component. components/Form.html.jinja {# action = ... method = 'post' multipart = false #} < form method = \" {{ method }} \" action = \" {{ action }} \" {% - if multipart %} enctype = \"multipart/form-data\" {% endif %} > {{ content }} </ form > In this example, the component takes three attributes: \u201caction\u201d, \u201cmethod\u201d, and \u201cmultipart\u201d. The last two have a default value, so they are optional, but the first one has ... as value*. That means that it must be passed when rendering this component. So all of these are valid forms to use this component: < Form action = \"/new\" > ... </ Form > < Form action = \"/new\" method = \"PATCH\" > ... </ Form > < Form multipart = {{ false }} action=\"/new\" > ... </ Form > The values of the declared attributes can be used in the template as values with the same name. Non-string attributes # In the example above, both \u201caction\u201d and \u201cmethod\u201d are strings, but \u201cmultipart\u201d is a boolean, so we cannot pass it like multipart=\"false\" because that will make it a string that evaluates as True , which is the opposite of what we want. Instead, we must use Jinja\u2019s print variable syntax ( {{ value }} ). Inside, you can use datetimes, objects, Python expressions, etc. {# A datetime value #} < DateTime date = {{ datetime_value }} / > {# A query result #} < Post post = {{ post }} / > {# In-place calculations #} < FooBar number = {{ 2 ** 10 }} / > {# A list #} < FooBar items = {{ [ 1 , 2 , 3 , 4 ] }} / > Components with content # So far we have seen self-closing components, but there is another, much more useful type: components that wrap other HTML content and/or other components. {# Self-closing component #} < Name attributes /> {# Component with content #} < Name attributes > ...content here... </ Name > A great use case is to make layout components: components/PageLayout.html.jinja {# title = ... #} <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > {{ title }} </ title > </ head > < body > {{ content }} </ body > components/ArchivePage.html.jinja {# posts = ... #} < PageLayout title = \"Archive\" > {% for post in posts %} < Post post = {{ post }} / > {% endfor %} </ PageLayout > Everything between the open and close tags of the components will be rendered and passed to the PageLayout component as a special content variable. To test a component in isolation, you can also manually send a content attribute: catalog . render ( \"PageLayout\" , title = \"Hello world\" , content = \"TEST\" ) Extra attributes # If you pass attributes not declared in a component, those are not discarded, but rather collected in a attrs object. Read more about it in the next section.","title":"Component Attributes"},{"location":"guide/attributes/#component-attributes","text":"More often than not, a component takes one or more attributes to render. Every attribute must be declared in the metadata section (the comment at the top) of the component. components/Form.html.jinja {# action = ... method = 'post' multipart = false #} < form method = \" {{ method }} \" action = \" {{ action }} \" {% - if multipart %} enctype = \"multipart/form-data\" {% endif %} > {{ content }} </ form > In this example, the component takes three attributes: \u201caction\u201d, \u201cmethod\u201d, and \u201cmultipart\u201d. The last two have a default value, so they are optional, but the first one has ... as value*. That means that it must be passed when rendering this component. So all of these are valid forms to use this component: < Form action = \"/new\" > ... </ Form > < Form action = \"/new\" method = \"PATCH\" > ... </ Form > < Form multipart = {{ false }} action=\"/new\" > ... </ Form > The values of the declared attributes can be used in the template as values with the same name.","title":"Component Attributes"},{"location":"guide/attributes/#non-string-attributes","text":"In the example above, both \u201caction\u201d and \u201cmethod\u201d are strings, but \u201cmultipart\u201d is a boolean, so we cannot pass it like multipart=\"false\" because that will make it a string that evaluates as True , which is the opposite of what we want. Instead, we must use Jinja\u2019s print variable syntax ( {{ value }} ). Inside, you can use datetimes, objects, Python expressions, etc. {# A datetime value #} < DateTime date = {{ datetime_value }} / > {# A query result #} < Post post = {{ post }} / > {# In-place calculations #} < FooBar number = {{ 2 ** 10 }} / > {# A list #} < FooBar items = {{ [ 1 , 2 , 3 , 4 ] }} / >","title":"Non-string attributes"},{"location":"guide/attributes/#components-with-content","text":"So far we have seen self-closing components, but there is another, much more useful type: components that wrap other HTML content and/or other components. {# Self-closing component #} < Name attributes /> {# Component with content #} < Name attributes > ...content here... </ Name > A great use case is to make layout components: components/PageLayout.html.jinja {# title = ... #} <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > {{ title }} </ title > </ head > < body > {{ content }} </ body > components/ArchivePage.html.jinja {# posts = ... #} < PageLayout title = \"Archive\" > {% for post in posts %} < Post post = {{ post }} / > {% endfor %} </ PageLayout > Everything between the open and close tags of the components will be rendered and passed to the PageLayout component as a special content variable. To test a component in isolation, you can also manually send a content attribute: catalog . render ( \"PageLayout\" , title = \"Hello world\" , content = \"TEST\" )","title":"Components with content"},{"location":"guide/attributes/#extra-attributes","text":"If you pass attributes not declared in a component, those are not discarded, but rather collected in a attrs object. Read more about it in the next section.","title":"Extra attributes"},{"location":"guide/css_and_js/","text":"Adding CSS and JS # Your components might need custom styles or custom JavaScript for many reasons. Instead of using global stylesheet or scripts files, writing assets per individual component has several advantages: Portability : You can copy a component from one project to another kmowing it will keep working as expected. Performance : On each page, only load the css and js that you need. Also, the browser will already have cached the assets of the components for other pages that use them. Simple testing : You can test the JS of a component indepently from others. Declaring assets # The css and/or the js of a component must be declared in the metatada header: { # css = [ ... ] js = [ ... ] ... #} The filepaths must be relative to the root of your components catalog (e.g.: components/ ). Both of these list are optional. Including assets in your pages # The catalog will collect all css and js file paths from the components used on a \u201cpage\u201d render on the catalog.collected_css and catalog.collected_js lists. For example, after rendering this component: components/MyPage.html.jinja {# css = ['mypage.css'] js = ['mypage.js'] -#} < Layout title = \"My page\" > < Card > < CardBody > < h1 > Lizard </ h1 > < p > The Iguana is a type of lizard </ p > </ CardBody > < CardActions > < Button size = \"small\" > Share </ Button > </ CardActions > </ Card > </ Layout > Asuming the Card , and Button components declare css assests, this will the state of the collected_css list: catalog . collected_css [ 'mypage.css' , 'card.css' , 'button.css' ] You can add the <link> and <script> tags in your page automatically by rendering the global components_assets variable in your layout component like this: components/Layout.html.jinja {# title = '' #} <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > {{ title }} </ title > {{ components_assets }} </ head > < body > {{ content }} </ body > </ html > The variable will be rendered as: < link rel = \"stylesheet\" href = \"/static/components/mypage.css\" > < link rel = \"stylesheet\" href = \"/static/components/card.css\" > < link rel = \"stylesheet\" href = \"/static/components/button.css\" > < script src = \"/static/components/mypage.js\" defer ></ script > < script src = \"/static/components/card.js\" defer ></ script > < script src = \"/static/components/button.js\" defer ></ script > Middleware # The tags above will not work at all if your application can\u2019t return the content of those files, and right now it can\u2019t. For that reason, Template Components include a WSGI middleware that will process those URLs if you add it to your application. from flask import Flask from tcom import Catalog app = Flask ( __name__ ) # Here we add the flask Jinja globals, filters, etc. # like `url_for()` catalog = tcom . Catalog ( globals = app . jinja_env . globals , filters = app . jinja_env . filters , tests = app . jinja_env . tests , extensions = app . jinja_env . extensions , ) catalog . add_folder ( \"myapp/components\" ) app . wsgi_app = catalog . get_middleware ( app . wsgi_app , autorefresh = app . debug , ) The middleware uses the battle-tested Whitenoise library and it will only respond to the .css and .js files inside the component(s) folder(s) (you can configure it to also return files with other extensions). Good practices # CSS Scoping # The styles of your components will not be auto-scoped. This means the styles of a component can affect other components, and, likewise, it will be affected by global styles or the styles of other components. To protect yourself against that, always add a custom class to the root element of your components and use it to scope the rest of the component styles. Always use a class instead of an id, or the component will not be usable more than once per page. Example: components/Card.html.jinja {# css=['card.css'] } {% do attrs.add_class ( \"Card\" ) - %} < div {{ attrs.render () }} > < h1 > My Card </ h1 > ... </ div > components/card.css /* \ud83d\udeab DO NOT do this */ h1 { font-size : 2 em ; } /* \ud83d\udc4d DO THIS instead */ . Card h1 { font-size : 2 em ; } JS events # Your components might be inserted in the page on-the fly, after the JavaScript files has been loaded and executed. So, attaching events to the elements on the page on load will not be enough: components/card.js // This will fail for any Card component inserted after page load document . querySelectorAll ( '.Card button.share' ) . forEach ( ( node ) => { node . addEventListener ( \"click\" , handleClick ) }) /* ... etc ... */ An alternative can be using the MutationObserver JS API to detect changes to the document and re-attach the event to all the components present: components/card.js new MutationObserver ( ( mutationList ) => { mutationList . forEach ( ( mutation ) => { if ( mutation . type !== \"childList\" ) return mutation . addedNodes . forEach ( ( node ) => { if ( node . nodeType === 1 ) { addEvents ( node ) } }) }) }) . observe ( document . body , { subtree : true , childList : true , attributes : false , characterData : false }) function addEvents ( root ) { /* Attach events to all the child components of the new node */ root . querySelectorAll ( '.Card button.share' ) . forEach ( ( node ) => { node . addEventListener ( \"click\" , handleClick ) }) } // We call it a first time to attach the events for the // components present on the document on page load addEvents ( document ) /* ... etc ... */","title":"Adding CSS and JS"},{"location":"guide/css_and_js/#adding-css-and-js","text":"Your components might need custom styles or custom JavaScript for many reasons. Instead of using global stylesheet or scripts files, writing assets per individual component has several advantages: Portability : You can copy a component from one project to another kmowing it will keep working as expected. Performance : On each page, only load the css and js that you need. Also, the browser will already have cached the assets of the components for other pages that use them. Simple testing : You can test the JS of a component indepently from others.","title":"Adding CSS and JS"},{"location":"guide/css_and_js/#declaring-assets","text":"The css and/or the js of a component must be declared in the metatada header: { # css = [ ... ] js = [ ... ] ... #} The filepaths must be relative to the root of your components catalog (e.g.: components/ ). Both of these list are optional.","title":"Declaring assets"},{"location":"guide/css_and_js/#including-assets-in-your-pages","text":"The catalog will collect all css and js file paths from the components used on a \u201cpage\u201d render on the catalog.collected_css and catalog.collected_js lists. For example, after rendering this component: components/MyPage.html.jinja {# css = ['mypage.css'] js = ['mypage.js'] -#} < Layout title = \"My page\" > < Card > < CardBody > < h1 > Lizard </ h1 > < p > The Iguana is a type of lizard </ p > </ CardBody > < CardActions > < Button size = \"small\" > Share </ Button > </ CardActions > </ Card > </ Layout > Asuming the Card , and Button components declare css assests, this will the state of the collected_css list: catalog . collected_css [ 'mypage.css' , 'card.css' , 'button.css' ] You can add the <link> and <script> tags in your page automatically by rendering the global components_assets variable in your layout component like this: components/Layout.html.jinja {# title = '' #} <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > {{ title }} </ title > {{ components_assets }} </ head > < body > {{ content }} </ body > </ html > The variable will be rendered as: < link rel = \"stylesheet\" href = \"/static/components/mypage.css\" > < link rel = \"stylesheet\" href = \"/static/components/card.css\" > < link rel = \"stylesheet\" href = \"/static/components/button.css\" > < script src = \"/static/components/mypage.js\" defer ></ script > < script src = \"/static/components/card.js\" defer ></ script > < script src = \"/static/components/button.js\" defer ></ script >","title":"Including assets in your pages"},{"location":"guide/css_and_js/#middleware","text":"The tags above will not work at all if your application can\u2019t return the content of those files, and right now it can\u2019t. For that reason, Template Components include a WSGI middleware that will process those URLs if you add it to your application. from flask import Flask from tcom import Catalog app = Flask ( __name__ ) # Here we add the flask Jinja globals, filters, etc. # like `url_for()` catalog = tcom . Catalog ( globals = app . jinja_env . globals , filters = app . jinja_env . filters , tests = app . jinja_env . tests , extensions = app . jinja_env . extensions , ) catalog . add_folder ( \"myapp/components\" ) app . wsgi_app = catalog . get_middleware ( app . wsgi_app , autorefresh = app . debug , ) The middleware uses the battle-tested Whitenoise library and it will only respond to the .css and .js files inside the component(s) folder(s) (you can configure it to also return files with other extensions).","title":"Middleware"},{"location":"guide/css_and_js/#good-practices","text":"","title":"Good practices"},{"location":"guide/css_and_js/#css-scoping","text":"The styles of your components will not be auto-scoped. This means the styles of a component can affect other components, and, likewise, it will be affected by global styles or the styles of other components. To protect yourself against that, always add a custom class to the root element of your components and use it to scope the rest of the component styles. Always use a class instead of an id, or the component will not be usable more than once per page. Example: components/Card.html.jinja {# css=['card.css'] } {% do attrs.add_class ( \"Card\" ) - %} < div {{ attrs.render () }} > < h1 > My Card </ h1 > ... </ div > components/card.css /* \ud83d\udeab DO NOT do this */ h1 { font-size : 2 em ; } /* \ud83d\udc4d DO THIS instead */ . Card h1 { font-size : 2 em ; }","title":"CSS Scoping"},{"location":"guide/css_and_js/#js-events","text":"Your components might be inserted in the page on-the fly, after the JavaScript files has been loaded and executed. So, attaching events to the elements on the page on load will not be enough: components/card.js // This will fail for any Card component inserted after page load document . querySelectorAll ( '.Card button.share' ) . forEach ( ( node ) => { node . addEventListener ( \"click\" , handleClick ) }) /* ... etc ... */ An alternative can be using the MutationObserver JS API to detect changes to the document and re-attach the event to all the components present: components/card.js new MutationObserver ( ( mutationList ) => { mutationList . forEach ( ( mutation ) => { if ( mutation . type !== \"childList\" ) return mutation . addedNodes . forEach ( ( node ) => { if ( node . nodeType === 1 ) { addEvents ( node ) } }) }) }) . observe ( document . body , { subtree : true , childList : true , attributes : false , characterData : false }) function addEvents ( root ) { /* Attach events to all the child components of the new node */ root . querySelectorAll ( '.Card button.share' ) . forEach ( ( node ) => { node . addEventListener ( \"click\" , handleClick ) }) } // We call it a first time to attach the events for the // components present on the document on page load addEvents ( document ) /* ... etc ... */","title":"JS events"},{"location":"guide/extra/","text":"Extra Attributes # If you pass attributes not declared in a component, those are not discarded, but rather collected in a attrs object that can render these extra attributes calling attrs.render() For example, this component: components/Card.html.jinja {# title = ... #} < div {{ attrs.render () }} > < h1 > {{ title }} </ h1 > {{ content }} </ div > Called as: < Card title = \"Products\" class = \"bg-blue-500 mb-10\" open > bla </ Card > Will be rendered as: < div class = \"bg-blue-500 mb-10\" open > < h1 > Products </ h1 > bla </ div > You can add or remove attributes before rendering them using the other methods of the attrs object. For example: {# title = ... #} {% do attrs.add_class ( \"card\" ) - %} < div {{ attrs.render () }} > < h1 > {{ title }} </ h1 > {{ content }} </ div > attrs methods # .add(name, value=True) # Adds an attribute or sets a property. Pass a name and a value to set an attribute. Omit the value or use True as value to set a property instead. {% do attrs.add ( \"disabled\" ) %} {% do attrs.add ( \"readonly\" , True ) %} {% do attrs.add ( \"data-test\" , \"foobar\" ) %} {% do attrs.add ( \"id\" , 3 ) %} .remove(name) # Removes an attribute or property. {% if active - %} {% do attrs.remove ( \"disabled\" ) %} {% - endif %} .add_class(name) / .add_classes(name1, name2, ...) # Adds one or more classes to the list of classes (both are actually the same method). {% do attrs.add_class ( \"card\" ) %} {% do attrs.add_classes ( \"active\" , \"animated\" , \"bright\" ) %} {% do attrs.add_classes ( \"active animated bright\" ) %} .remove_class(name) / .remove_classes(name1, name2, ...) # Removes one or more classes from the list of classes (both are actually the same method). {% do attrs.remove_class ( \"hidden\" ) %} {% do attrs.remove_classes ( \"active\" , \"animated\" ) %} .setdefault(name, value=True) # Adds an attribute or sets a property, but only if it\u2019s not already present . Pass a name and a value to set an attribute. Omit the value or use True as value to set a property instead. {% do attrs.setdefault ( \"aria-label\" , \"Products\" ) %} .update(dd=None, **kw) # Updates several attributes/properties with the values of dd and kw dicts. {% - do attrs.update ( role = \"tab\" , aria_selected = \"true\" if active else \"false\" , aria_controls = target , tabindex = \"0\" if active else \"-1\" , ) - %} The underscores in the names will be translated automatically to dashes, so aria_selected will become the attribute aria-selected . .get(name, default=None) # Returns the value of the attribute or property, or the default value if it doesn\u2019t exists. {% - set role = attrs.get ( \"role\" , \"tab\" ) .render() # Renders the attributes and properties as a string. To provide consistent output, the attributes and properties are sorted by name and rendered like this: <sorted attributes> + <sorted properties> . < button {{ attrs.render () }} > {{ content }} </ button > Warning Using {{ attrs.render() }} as attributes for other component will not work , because the components are translated to macros before the page render. You must pass them as the special attribute __attrs . {#--- WRONG \ud83d\ude35 ---#} < MyButton {{ attrs.render () }} /> {#--- GOOD \ud83d\udc4d ---#} < MyButton __attrs = {{ attrs }} / > {#--- ALSO AN OPTION ---#} {# btn_class = '' #} < MyButton class = {{ btn_class }} / >","title":"Extra Attributes"},{"location":"guide/extra/#extra-attributes","text":"If you pass attributes not declared in a component, those are not discarded, but rather collected in a attrs object that can render these extra attributes calling attrs.render() For example, this component: components/Card.html.jinja {# title = ... #} < div {{ attrs.render () }} > < h1 > {{ title }} </ h1 > {{ content }} </ div > Called as: < Card title = \"Products\" class = \"bg-blue-500 mb-10\" open > bla </ Card > Will be rendered as: < div class = \"bg-blue-500 mb-10\" open > < h1 > Products </ h1 > bla </ div > You can add or remove attributes before rendering them using the other methods of the attrs object. For example: {# title = ... #} {% do attrs.add_class ( \"card\" ) - %} < div {{ attrs.render () }} > < h1 > {{ title }} </ h1 > {{ content }} </ div >","title":"Extra Attributes"},{"location":"guide/extra/#attrs-methods","text":"","title":"attrs methods"},{"location":"guide/extra/#addname-valuetrue","text":"Adds an attribute or sets a property. Pass a name and a value to set an attribute. Omit the value or use True as value to set a property instead. {% do attrs.add ( \"disabled\" ) %} {% do attrs.add ( \"readonly\" , True ) %} {% do attrs.add ( \"data-test\" , \"foobar\" ) %} {% do attrs.add ( \"id\" , 3 ) %}","title":".add(name, value=True)"},{"location":"guide/extra/#removename","text":"Removes an attribute or property. {% if active - %} {% do attrs.remove ( \"disabled\" ) %} {% - endif %}","title":".remove(name)"},{"location":"guide/extra/#add_classname-add_classesname1-name2","text":"Adds one or more classes to the list of classes (both are actually the same method). {% do attrs.add_class ( \"card\" ) %} {% do attrs.add_classes ( \"active\" , \"animated\" , \"bright\" ) %} {% do attrs.add_classes ( \"active animated bright\" ) %}","title":".add_class(name) / .add_classes(name1, name2, ...)"},{"location":"guide/extra/#remove_classname-remove_classesname1-name2","text":"Removes one or more classes from the list of classes (both are actually the same method). {% do attrs.remove_class ( \"hidden\" ) %} {% do attrs.remove_classes ( \"active\" , \"animated\" ) %}","title":".remove_class(name) / .remove_classes(name1, name2, ...)"},{"location":"guide/extra/#setdefaultname-valuetrue","text":"Adds an attribute or sets a property, but only if it\u2019s not already present . Pass a name and a value to set an attribute. Omit the value or use True as value to set a property instead. {% do attrs.setdefault ( \"aria-label\" , \"Products\" ) %}","title":".setdefault(name, value=True)"},{"location":"guide/extra/#updateddnone-kw","text":"Updates several attributes/properties with the values of dd and kw dicts. {% - do attrs.update ( role = \"tab\" , aria_selected = \"true\" if active else \"false\" , aria_controls = target , tabindex = \"0\" if active else \"-1\" , ) - %} The underscores in the names will be translated automatically to dashes, so aria_selected will become the attribute aria-selected .","title":".update(dd=None, **kw)"},{"location":"guide/extra/#getname-defaultnone","text":"Returns the value of the attribute or property, or the default value if it doesn\u2019t exists. {% - set role = attrs.get ( \"role\" , \"tab\" )","title":".get(name, default=None)"},{"location":"guide/extra/#render","text":"Renders the attributes and properties as a string. To provide consistent output, the attributes and properties are sorted by name and rendered like this: <sorted attributes> + <sorted properties> . < button {{ attrs.render () }} > {{ content }} </ button > Warning Using {{ attrs.render() }} as attributes for other component will not work , because the components are translated to macros before the page render. You must pass them as the special attribute __attrs . {#--- WRONG \ud83d\ude35 ---#} < MyButton {{ attrs.render () }} /> {#--- GOOD \ud83d\udc4d ---#} < MyButton __attrs = {{ attrs }} / > {#--- ALSO AN OPTION ---#} {# btn_class = '' #} < MyButton class = {{ btn_class }} / >","title":".render()"}]}